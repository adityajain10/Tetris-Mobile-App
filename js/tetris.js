
var T = [ /* [kind(7)][rotation(4)][horizontal blocks(5)][vertical blocks(5)] */
[ // kind: square(O)
	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 0, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 3, 3, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	],	

[ // kind: I
	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 6, 6, 6, 6],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 0, 6, 0, 0],
		[0, 0, 6, 0, 0],
		[0, 0, 6, 0, 0],
		[0, 0, 6, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[6, 6, 6, 6, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 6, 0, 0],
		[0, 0, 6, 0, 0],
		[0, 0, 6, 0, 0],
		[0, 0, 6, 0, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	],	

[ // kind: L
	[	[0, 0, 0, 0, 0],
		[0, 0, 2, 0, 0],
		[0, 0, 2, 0, 0],
		[0, 0, 2, 2, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 2, 2, 2, 0],
		[0, 2, 0, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 2, 2, 0, 0],
		[0, 0, 2, 0, 0],
		[0, 0, 2, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 2, 0],
		[0, 2, 2, 2, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	],	

[ // kind: L mirrored
	[	[0, 0, 0, 0, 0],
		[0, 0, 7, 0, 0],
		[0, 0, 7, 0, 0],
		[0, 7, 7, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 7, 0, 0, 0],
		[0, 7, 7, 7, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 0, 7, 7, 0],
		[0, 0, 7, 0, 0],
		[0, 0, 7, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 7, 7, 7, 0],
		[0, 0, 0, 7, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	],	

[ // kind: N
	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 1, 0],
		[0, 0, 1, 1, 0],
		[0, 0, 1, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 1, 1, 0, 0],
		[0, 0, 1, 1, 0],
		[0, 0, 0, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 0, 1, 0, 0],
		[0, 1, 1, 0, 0],
		[0, 1, 0, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 0, 0, 0],
		[0, 1, 1, 0, 0],
		[0, 0, 1, 1, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	],	

[ // kind: N mirrored
	[	[0, 0, 0, 0, 0],
		[0, 0, 5, 0, 0],
		[0, 0, 5, 5, 0],
		[0, 0, 0, 5, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 5, 5, 0],
		[0, 5, 5, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 5, 0, 0, 0],
		[0, 5, 5, 0, 0],
		[0, 0, 5, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 0, 0, 0],
		[0, 0, 5, 5, 0],
		[0, 5, 5, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	],	

[ // kind: T
	[	[0, 0, 0, 0, 0],
		[0, 0, 4, 0, 0],
		[0, 0, 4, 4, 0],
		[0, 0, 4, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 1

	[	[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0],
		[0, 4, 4, 4, 0],
		[0, 0, 4, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 2

	[	[0, 0, 0, 0, 0],
		[0, 0, 4, 0, 0],
		[0, 4, 4, 0, 0],
		[0, 0, 4, 0, 0],
		[0, 0, 0, 0, 0]	], // rotation 3

	[	[0, 0, 0, 0, 0],
		[0, 0, 4, 0, 0],
		[0, 4, 4, 4, 0],
		[0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0]	]  // rotation 4
	]	
];
// ENDOF T }

// Displacement of the piece to the position where it is first drawn in the board when it is created
// HEADOF P {
var P = /* [kind(7)][rotation(4)][initial x/y position(2)] */
[
/* Square(0) */
  [
    [2, -3], 
    [2, -3],
    [2, -3],
    [2, -3]
   ],
/* I(1) */
  [
    [2, -2],
    [2, -4],
    [2, -2],
    [2, -3]
   ],
/* L(2) */
  [
    [2, -3],
    [3, -3],
    [3, -3],
    [2, -2]
   ],
/* L mirrored(3) */
  [
    [3, -3],
    [2, -2],
    [2, -3],
    [2, -3]
   ],
/* N(4) */
  [
    [2, -3],
    [2, -3],
    [3, -3],
    [2, -2]
   ],
/* N mirrored(5) */
  [
    [2, -3],
    [3, -3],
    [3, -3],
    [3, -2]
   ],
/* T(6) */
  [
    [2, -3],
    [2, -3],
    [3, -3],
    [2, -2]
   ]
];
// ENDOF P }

var canvas = document.getElementById('canvas');
canvas.width = 400;
canvas.height = 400;
canvas.setAttribute('tabindex', '0');
canvas.focus();
canvas.addEventListener("keydown", onKeydown, false);
var KEY_WHICH = 0;
var KEY_ESCAPE = 27;
var KEY_LEFT = 37;
var KEY_UP = 38;
var KEY_RIGHT = 39;
var KEY_DOWN = 40;
var KEY_X = 88;
var KEY_P = 80;
var KEY_R = 82;
var KEY_Z = 90;

function onKeydown(event) {
    // set KEY_WHICH to key code
    // AZ: added preventDefault() to avoid page scroll with up and down arrows
    //     IE does not support preventDefault(), but supports returnValue
		if (event.keyCode) {KEY_WHICH = event.keyCode; 
      if (event.preventDefault) {event.preventDefault();} 
      else {event.returnValue = false;} 
    } 
    else {
      if (event.which) {KEY_WHICH = event.which; 
        if (event.preventDefault) {event.preventDefault();} 
        else {event.returnValue = false;} 
      } 
    }
}  // function onKeydown(event) 

var CANVAS_WIDTH = canvas.width;
var CANVAS_HEIGHT = canvas.height;

var WAIT_TIME = 700;
var PAUSE = false;

var STAGE = canvas.getContext('2d');
var GREEN = "rgb(0, 255, 0)";       // 1
var BLUE = "rgb(0, 0, 255)";        // 2
var RED = "rgb(255, 0, 0)";         // 3
var YELLOW = "rgb(255, 215, 0)";    // 4
var SKYBLUE = "rgb(103,205, 255)";  // 5
var ORANGE = "rgb(255, 103, 0)";    // 6
var VIOLET = "rgb(205, 0, 255)";    // 7
var GRAY = "rgb(200, 200, 200)";
var DARKGRAY = "rgb(80, 80, 80)";
var CLEAR = "rgba(0, 0, 0, 0)";
var UNIT = 20;
var LEN = UNIT - 1;
var BOARD_POSITION = 110;
var BORDER_WIDTH = 10;
var BOARD_WIDTH = 10;
var BOARD_HEIGHT = 20;
var BLOCKS_SIZE = 5;

// HEADOF class Tetromino {
function Tetromino() {
	return {
		getBlockType: function(kind, rotation, h, v) {
						  return T[kind][rotation][h][v];
					  },
			getX0: function(kind, rotation) {
						  return P[kind][rotation][0];
					  },
			getY0: function(kind, rotation) {
						  return P[kind][rotation][1];
					  }
	};
}
// ENDOF class Tetromino }

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//                    HEADOF class Board {
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
function Board(tetromino, height) {
	// private:
	var _STATE = { FREE: 0, FILLED: 1};
	var _height = height;
	var _board; // an array holds Board's filled state
	var _t = tetromino;
	var _score = 0;
	var _scoreboard; // an array holds deleted lines, used to calculate _score

	function initBoard() {
		_board = new Array(BOARD_WIDTH);
		for (var i = 0; i < BOARD_WIDTH; i++) {
			_board[i] = new Array(BOARD_HEIGHT);
			for (var j = 0; j < BOARD_HEIGHT; j++) {
				_board[i][j] = 0;
			}
		}
	}
	function initScoreboard() {
		_scoreboard = new Array(BOARD_HEIGHT);
		for (var i = 0; i < _scoreboard.length; i++) {
			_scoreboard[i] = 0;
		}
	}
	function deleteLine(y) {
		for (var j = y; j > 0; j--) {
			for (var i = 0; i < BOARD_WIDTH; i++) {
				_board[i][j] = _board[i][j-1];
			}
		}
	}
	function collectScore(j) {
		_scoreboard[j] = 1;
	}

	// constructor:
	initBoard();
	initScoreboard();

	// public:
	return {
		calcScore: function() {
					  var j = 0;
					  while (j < _scoreboard.length) {
						  if (_scoreboard[j++] == 1) {  
							  if (_scoreboard[j++] == 1) {
								  if (_scoreboard[j++] == 1) {
									  if (_scoreboard[j++] == 1) {
										  _score += 800;
									  } else {
										  _score += 500;
									  }
								  } else {
									  _score += 300;
								  }
							  } else {
								  _score += 100;
							  }
						  } else {
							  _score += 0;
						  }
					  }
					  for (j = 0; j < _scoreboard.length; j++) {
						  _scoreboard[j] = 0;
					  }
					  return _score;
				  },
		getXInPixels: function(x) {
						  return BOARD_POSITION - UNIT * BOARD_WIDTH / 2 + x * UNIT;
					  },
		getYInPixels: function(y) {
						  return _height - UNIT * BOARD_HEIGHT + y * UNIT;
					  },
		storeCurrentTetromino: function(x, y, kind, rotation) {
								   for (var i1 = x, i2 = 0; i1 < x + BLOCKS_SIZE; i1++, i2++) {
									   for (var j1 = y, j2 = 0; j1 < y + BLOCKS_SIZE; j1++, j2++) {
										   if (_t.getBlockType(kind, rotation, j2, i2) !== 0) {
											   _board[i1][j1] = _STATE.FILLED;
                       }
									   }
								   }
							   },
		isGameOver: function() {
						for (var i = 0; i < BOARD_WIDTH; i++) {
							if (_board[i][0] == _STATE.FILLED) {
//alert("game over");              
								return true;
              }
						}
						return false;
					},
		deletePossibleLines: function() {
								 for (var j = 0; j < BOARD_HEIGHT ; j++) {
									 var i = 0;
									 while (i < BOARD_WIDTH) {
										 if (_board[i][j] != _STATE.FILLED) {
											 break;
                     }
										 i++;
									 }

									 if (i == BOARD_WIDTH) {
                     playSound('touch');
										 deleteLine(j);
										 collectScore(j);
									 }
								 }
							 },
		isFreeBlock: function(x, y) {
						 if (_board[x][y] == _STATE.FREE) {
							 return true;
              }
						 return false;
					 },
		// x: horizontal position in board, left top corner is (0, 0), -> x>0
		// y: vertical position in board, \/ y>0
		isPossibleMovement: function(x, y, kind, rotation) {
								for (var i1 = x, i2 = 0; i1 < x + BLOCKS_SIZE; i1++, i2++) {
									for (var j1 = y, j2 = 0; j1 < y + BLOCKS_SIZE; j1++, j2++) {
										if (i1 < 0 || i1 > BOARD_WIDTH - 1 || j1 > BOARD_HEIGHT - 1) {
											if (_t.getBlockType(kind, rotation, j2, i2) !== 0) {
                         playSound('pop');
											   return false;
											}
										}
										if (j1 >= 0) {
											if (_t.getBlockType(kind, rotation, j2, i2) !== 0 && !this.isFreeBlock(i1, j1)) {
                        playSound('pop');
												return false;
                      }
										}
									}
								}
								return true;
							}
	} // ENDOF class Board>public:
;}
// ENDOF class Board }

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//                        HEADOF class UI {
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
function UI() {
	// private:
	// constructor:
	// public:
	return {
		getScreenHeight: function() {
			return CANVAS_HEIGHT;
		},
		getKey: function() {
					 var which = KEY_WHICH;
					 KEY_WHICH = 0;
					 return which;
				 },
		drawRect: function(x, y, width, height, color) {
					  STAGE.fillStyle = color;
					  STAGE.fillRect(x, y, width, height);
				  },
		clearScreen: function() {
						 STAGE.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
					 },
		writeText: function(text) {
					   STAGE.font = "30px Courier New";
					   STAGE.textAlign = "right";
					   STAGE.textBaseline = "top";
					   STAGE.fillStyle = "rgb(0, 0, 0)";
					   STAGE.fillText(text, BOARD_POSITION + 12 * UNIT, CANVAS_HEIGHT - (BOARD_HEIGHT - 12) * UNIT);
				   },
		writeStatus: function(arg) {  
      // status: =0 clear, =1 Paused, =2 Game Over
      var msg;
      msg = "";
      if (arg == 1) {msg = "Paused ";}
      if (arg == 2) {msg = "Game Over";}
			STAGE.font = "bold 25px Courier New";
			STAGE.textAlign = "right";
			STAGE.textBaseline = "top";
			STAGE.fillStyle = RED;
			STAGE.fillText(msg, BOARD_POSITION + 13*UNIT, CANVAS_HEIGHT - (BOARD_HEIGHT - 9) * UNIT);
				   }
	}
;}
// ENDOF class UI }

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//                      HEADOF class Game {
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
function Game(board, tetromino, ui, height) {
	// private:
	var _height = height;
	var _board = board;
	var _t = tetromino;
	var _ui = ui;
	var _nextX, _nextY;
	var _nextKind, _nextRotation;
	this.x;
	this.y;
	this.kind;
	this.rotation;

	function getRandomInteger(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}
	function writeScore(score) {
		_ui.writeText(score);
	}
	function initGame() {
		_kind = getRandomInteger(0, 6);
		_rotation = getRandomInteger(0, 3);
		_x = _t.getX0(_kind, _rotation);
		_y = _t.getY0(_kind, _rotation);

		_nextKind = getRandomInteger(0, 6);
		_nextRotation = getRandomInteger(0, 3);
		_nextX = BOARD_WIDTH + 2;
		_nextY = 2;
	}
	function drawATetromino(x, y, kind, rotation) {
		var color;
		var pixelsX = _board.getXInPixels(x);
		var pixelsY = _board.getYInPixels(y);

		for (var i = 0; i < BLOCKS_SIZE; i++) {
			for (var j = 0; j < BLOCKS_SIZE; j++) {
				switch (_t.getBlockType(kind, rotation, j, i)) {
					case 1:
						color = GREEN;
						break;
					case 2:
						color = BLUE;
						break;
					case 3:
						color = RED;
						break;
					case 4:
						color = YELLOW;
						break;
					case 5:
						color = SKYBLUE;
						break;
					case 6:
						color = ORANGE;
						break;
					case 7:
						color = VIOLET;
						break;
					default:
						color = CLEAR;
						break;
				}
				
				if (_t.getBlockType(kind, rotation, j, i) !== 0) {
					_ui.drawRect(pixelsX + i * UNIT, pixelsY + j * UNIT, LEN, LEN, color);
				}
			}
		}
	}
	function drawBoard() {
		var x1 = BOARD_POSITION - UNIT * BOARD_WIDTH / 2 - 1;
		var x2 = BOARD_POSITION + UNIT * BOARD_WIDTH / 2;
		var y = height - UNIT * BOARD_HEIGHT;

		ui.drawRect(x1 - BORDER_WIDTH, y, BORDER_WIDTH, height - 1,GRAY);
		ui.drawRect(x2, y, BORDER_WIDTH, height - 1, GRAY);

		x1++;
		for (var i = 0; i < BOARD_WIDTH; i++) {
			for (var j = 0; j < BOARD_HEIGHT; j++) {
				if (!_board.isFreeBlock(i, j)) {
					_ui.drawRect(x1 + i * UNIT, y + j * UNIT, LEN, LEN, DARKGRAY);
        }
			}
		}
	}  // function drawBoard()

	// constructor:
	initGame();
	
	// public:
	return {
			getX: function() {
					  return _x;
				  },
			getY: function() {
					  return _y;
				  },
			getKind: function() {
						 return _kind;
					 },
			getRotation: function() {
							 return _rotation;
						 },
			setRotation: function(r) {
							 _rotation = r;
						 },
			increaseXByOne: function() {
								_x++;
							},
			increaseYByOne: function() {
								_y++;
							},
			decreaseXByOne: function() {
								_x--;
							},
			decreaseYByOne: function() {
								_y--;
							},
		drawScene: function() {
			drawBoard();
			drawATetromino(_x, _y, _kind, _rotation);
			drawATetromino(_nextX, _nextY, _nextKind, _nextRotation);
		},
		updateScore: function() {
				 		writeScore(_board.calcScore());
					 },
		generateANewTetromino: function() {
								   _kind = _nextKind;
								   _rotation = _nextRotation;
								   _x = _t.getX0(_kind, _rotation);
								   _y = _t.getY0(_kind, _rotation);

								   _nextKind = getRandomInteger(0, 6);
								   _nextRotation = getRandomInteger(0, 3);
							   },
		pause: function() {
			   }
	}
;}
// ENDOF class Game }


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//                       main loop section
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  // Global variables
	var ui = new UI();
	var height = ui.getScreenHeight();
	var t;
	var board;
	var game;
	var i = 0;
  var mainloop;  // interval variable

  // Set up new game and listen for keyboard actions
  function listen() {
   // set up new game
   playSound('pop');
   t = new Tetromino();
   board = new Board(t, height);
   game = new Game(board, t, ui, height);  // Set up new game
   // suppress background image and START button
   document.getElementById("az1").style.display = "none";
   document.getElementById("az2").style.display = "none";

    // start listening loop
	  mainloop = setInterval(function() {
    if (!PAUSE) {
	    canvas.focus();
		  ui.clearScreen();
	  	game.drawScene();
		  game.updateScore();
    }

		var key = ui.getKey();
		switch (key) {
			case KEY_ESCAPE:
				break;
			case KEY_LEFT:
        if (PAUSE) {break;}  // Don't do anything when paused
				if (board.isPossibleMovement(game.getX() - 1, game.getY(), game.getKind(), game.getRotation())) {
					game.decreaseXByOne();
        }
				break;
			case KEY_RIGHT:
        if (PAUSE) {break;}  // Don't do anything when paused
				if (board.isPossibleMovement(game.getX() + 1, game.getY(), game.getKind(), game.getRotation())) {
					game.increaseXByOne();
        }
				break;
			case KEY_DOWN:
        if (PAUSE) {break;}  // Don't do anything when paused
				if (board.isPossibleMovement(game.getX(), game.getY() + 1, game.getKind(), game.getRotation())) {
						game.increaseYByOne();
        }
				break;
			case KEY_X:
        if (PAUSE) {break;}  // Don't do anything when paused
				while (board.isPossibleMovement(game.getX(), game.getY() + 1, game.getKind(), game.getRotation())) {
						game.increaseYByOne();
        }
				board.storeCurrentTetromino(game.getX(), game.getY(), game.getKind(), game.getRotation());
				board.deletePossibleLines();
				if (board.isGameOver()) {
					clearInterval(mainloop);
          ui.writeStatus(2);  // Game Over
          playSound('done');
          document.getElementById("az2").style.display = "block"; // restore START button
        }
				game.generateANewTetromino();
				break;
			case KEY_UP:
			case KEY_Z:
        if (PAUSE) {break;}  // Don't do anything when paused
        playSound('turn');
				if (board.isPossibleMovement(game.getX(), game.getY(), game.getKind(), (game.getRotation() + 1) % 4)) {
						game.setRotation((game.getRotation() + 1) % 4);
        }
				break;
			case KEY_P:  // allow P to toggle PAUSE state
        if (!PAUSE) {
          PAUSE = true;
          ui.writeStatus(1);  // Pause
        }
        else {
          PAUSE = false;
          ui.writeStatus(0); 
        }
				break;
			case KEY_R:
				PAUSE = false;  // Resume
        ui.writeStatus(0); 
				break;
      default:
        break; // nothing
		}

		if (!PAUSE && (++i >= 50)) { 
			if (board.isPossibleMovement(game.getX(), game.getY() + 1, game.getKind(), game.getRotation())) {
				game.increaseYByOne();
			} else {
				board.storeCurrentTetromino(game.getX(), game.getY(), game.getKind(), game.getRotation());
				board.deletePossibleLines();
				if (board.isGameOver()) {
					clearInterval(mainloop);
          ui.writeStatus(2);  // Game Over
          playSound('done');
          document.getElementById("az2").style.display = "block";  // restore START button
				}
				game.generateANewTetromino();
			}
			i = 0;
		}
	}, 10); // ENDOF setInterval }
 } // end listen()
